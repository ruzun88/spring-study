# 객체 지향 설계와 스프링
## 자바의 과거
### EJB(Enterprise Java Beans)의 흥행
- 자바의 정파 기술로, 인정된 표준 기술이었다.
- 레퍼런스도 많아지면서 이를 사용한 솔루션들이 기술영업을 통해 잘팔렸다.
- 분산처리 지원이 잘 되는 등 이론적 부분이 좋았다.
- ORM인 Entity Bean을 가지고 있었다.
- But, 비쌌다. 대당 수천만원...

### EJB 지옥
- 개발자가 쓰기에 복잡했다.
- 코드도 지저분해졌다.
- 컨테이너 띄우는데도 한참이 걸렸다.
- EJB 인터페이스에 의존적으로 자바 코드를 작성해야 했다.
- POJO 라는 말이 등장하게 된 배경

### 스프링의 등장
- EJB를 비판하면서, 대안을 제시했는데, 그것이 추후 스프링이 되었다.
- 실무 개발자가 빡쳐서 EJB Entity Bean 기술을 대체할 Hibernate도 만들어졌다.
- Hibernate를 활용하여 자바 표준인 JPA가 탄생하였다.

## 스프링의 역사
### 전설의 시작
- 2002년 로드 존슨이 EJB의 문제점을 지적하며 책을 출간하였다.
- 나오자마자 3만 라인 정도의 예제 코드를 실제 프로젝트에 베껴 쓰는 등 흥행하게 되었다.
- J2EE(EJB)라는 겨울을 넘어 새로운 시작이라는 뜻으로 Spring으로 명명되었다.

### 릴리즈
- XML으로 설정해야 했던 Spring F/W 1.0과 2.0
- Java 코드로 설정할 수 있는 3.0
- Java 8을 사용할 수 있는 4.0
- 2014년 스프링부트 1.0 출시
  - 스프링이 좋은데 설정이 복잡했다..
  - 웹서버를 띄우려면 설정 뿐만 아니라 War를 집어넣고 하는 불편함까지...
  - 스프링부트는 이러한 문제를 해결해주었다. (설정 최소화, 서버 내장)
- 리엑티브 프로그래밍이 지원되는 5.0
  - 리액티브 프로그래밍은 비동기 non-blocking을 가지고 개발 할 수 있게 된 것
- 2020년 9월 기준 스프링 F/W 5.2.x, 스프링 부트 2.3.x

## 스프링이란?
### 스프링이 제공하는 Libraries
참고 site: https://spring.io/projects
- Spring Data: DB와 관계없이 대부분의 CRUD는 비슷함. 이를 처리할 수 있도록 제공하는 Spring의 DB 처리 기술
- Spring Session: 세션 기능을 편리하게 사용할 수 있게 도와주는 것
- 시큐리티: 보안
- 스프링 Rest Docs: API 문서화를 편리하게 해줌
- 스프링 배치: 배치 처리에 특화된 기술
- 스프링 클라우드: 클라우드에 특화된 기술

### Spring FW
- 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트 등
- 웹 기술: MVC, WebFlux
- DB 접근 기술: Transaction, JDBC 등
- 기술 통합: 캐시, 메일, 원격 접근, 스케쥴링
- 테스트
- 언어

### Spring Boot
- 스프링을 편리하게 사용할 수 있도록 지원함, 최근에는 기본으로 사용
- stand-alone Web Application을 쉽게 생성 가능
- 손쉬운 빌드 구성을 위한 starter 종속성 제공 (starter만 땡겨오면 관련 필요한 것들을 다 가져와줌)
- 3rd party 라이브러리 자동 구성 (외부 라이브러리의 호환 여부를 고려하여 자동으로 버전 결정)
- 메트릭, 상태확인, 외부 구성 같은 프로덕션 준비 기능을 제공함 (운영시 상태확인할 수 있는 방법들)
- 설정이 편리함

### 스프링의 의미
- 문맥에 따라 다르게 사용된다.
  1. Spring DI container 기술 (빈 관리 등)
  1. 스프링 프레임워크
  1. 스프링 생태계 자체

### 스프링을 만든 이유 (핵심 컨셉)
- 자바 언어 기반의 F/W
- 객체 지향 언어가 가진 강력한 특징을 살려내는 F/W
- 좋은 객체 지향 어플리케이션을 개발할 수 있게 되와주는 F/W
- 좋은 객체 지향 어플리케이션이 뭘까? 라는 질문을 답하는 과정이 스프링을 이해하는 과정이다.

### 좋은 객체 지향 프로그래밍?
- 객체 지향 특징: 추상화, 상속, 캡슐화, 다형성.....
- 유연하고 변경이 용이
  - 부품을 갈아끼우듯이 해야 함
- `결론적으로 다형성(Polymorphism이 중요)`

### 역할과 구현을 분리
- 역할과 구현으로 구분하면, 유연하고 변경도 편하다.  
  (로미오 역할을 장동건이 하던, 원빈이 하던 기능이 다 돌아감)
- 장점
  1. 클라이언트는 대상의 역할(Interface)만 알면 됨
  2. 구현 대상의 내부를 몰라도 됨
  3. 심지어 구현 대상의 내부가 바뀌어도 영향받지 않음
  4. 구현 대상 자체를 변경해도 영향받지 않음
- 다형성 활용
  - 역할: 인터페이스
  - 구현: 인터페이스를 구현한 클래스, 구현 객체
- 확장 가능한 설계
- 인터페이스를 안정적으로 `잘 설계하는 것이 중요`

### 다형성의 본질
- 인터페이스를 구현한 객체 instance를 실행 시점에 유연하게 변경할 수 있다.
- 객체 사이의 협력관계를 이해하여야 다형성의 본질을 이해할 수 있다.
- 클라이언트 변경 없이 서버의 구현 기능을 유연하게 변경할 수 있다.

### 한계점
- 역할(interface)가 변하면 클라이언트, 서버 모두에 큰 변경이 발생한다.

### 스프링과 객체 지향
- 다형성이 가장 중요
- 제어의 역전, 의존관계 주입을 통해 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

## 객체 지향의 5가지 원칙(SOLID)
- 면접에 종종 등장하는 원칙

### 1. 단일 책임 원칙
- 한 클래스는 하나의 책임만 가진다.
- 하나의 책임은 상황에 따라 다르다.
- 중요한 기준은 `변경`이다. 변경이 있을 때, 파급효과가 적으면 단일 책임 원칙을 잘 따른 것
- 너무 작지도 않게, 너무 크지도 않게 설계가 필요하다.

### 2. 개방-폐쇄 원칙
- OCP (Open / Closed principle)
- 확장에는 열려있으나, 변경에는 닫혀있어야 한다.
- 다형성을 잘 활용해야 한다는 것
- 인터페이스를 구현한 새로운 클래스를 하나 만들어 새로운 기능을 구현한 것
- 그런데?
  - 클라이언트에서 구현 객체를 변경하려면 클라이언트 코드 변경이 일어나야 한다.
  - OCP 원칙을 지킬 수 없다는 것
- How to solve?
  - 스프링이 객체를 생성하고, 연관관계를 맺어준다.

### 3. 리스코프 치환 원칙
- Liskov substitution principle
- 다형성에서, 하위 클래스는 인터페이스 규약을 다 지켜야 한다.
- 액셀을 밟았을 때, 전진하는 interface를 만들었다면, 모든 instance에서 속도가 증가해야하지, 단 하나라도 감소하는 행위를 하면 안됨
- 컴파일은 잘 되나, 기능 신뢰에 대한 문제이다.

### 4. 인터페이스 분리 원칙
- Interface segregation principle
- 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다
- 인터페이스를 잘 쪼개야 한다.
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

### 5. 의존관계 역전 원칙
- Dependency inversion principle
- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
- 구현 클래스 말고, 인터페이스에 의존해야 한다.
- 역할에 의존해야 한다!
- XxxRepository repo = `new 하는 순간` DIP를 위반 한 것.

### 정리
- 다형성 만으로는 부품을 갈아끼우듯 개발이 불가능하며, 구현 객체 변경시 클라이언트도 함께 변경된다.
- 다형성 만으로는 OCP, DIP를 지킬 수 없다.
- 뭔가 더 필요하다.

## 객체 지향 설계와 스프링
- 스프링은 다음 기술로 다형성 + OCP, DIPfmf rksmdgkrp wldnjs
  - DI: 의존관계, 의존성 주입
  - DI 컨테이너 제공
- 클라이언트 코드 변경 없는 기능 확장 가능

### 정리
- 모든 설계에 역할과 구현을 분리하라!
- App 걸계는 배역만 잘 설계해두고, 배우는 언제든 유연하게 변경되어도 상관없도록 만드는 것이 좋은 객체 지향 설계이다.
- 이상적으로는 모든 설계에 인터페이스를 부여하자.

### 실무적 고민
- interface를 도입하면 추상화라는 비용이 발생한다.
- 기능 확장 가능성이 없다면, 구체 클래스를 직접 사용하고, 추후 꼭 필요할 때 리팩터링 해서 인터페이스를 도입하는 것도 방법이다. (설계자의 선택)